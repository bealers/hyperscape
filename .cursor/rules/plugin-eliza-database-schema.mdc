---
description: ElizaOS database schema patterns - shared tables, repositories, actions, providers
globs: packages/plugin-eliza/src/**/*.ts
alwaysApply: false
---

# Hyperscape Plugin - Database Schema Patterns

> Database schema patterns: shared tables, repositories, actions for writing, providers for reading.

## Reference Documentation

- **Database Schema**: https://docs.elizaos.ai/plugins/database-schema
- **Plugin Components**: https://docs.elizaos.ai/plugins/components
- **Memory**: `.cursor/memory/elizaos-database-schema.md`

## Database Access Pattern

**MANDATORY**: Always access database through runtime adapter

```typescript
const db = runtime.databaseAdapter.db;
const repository = new MyRepository(db);
```

**Rules:**
- ✅ **ALWAYS** access database via `runtime.databaseAdapter.db`
- ✅ **ALWAYS** use repository classes to encapsulate operations
- ✅ **ALWAYS** use Drizzle ORM query builder
- ✅ **NEVER** access database directly without repository

## Schema Definition Patterns

### Shared Tables (No agentId)

**Pattern:** Tables accessible by all agents

```typescript
import { pgTable, uuid, varchar, text, timestamp, jsonb, index } from 'drizzle-orm/pg-core';

export const userPreferencesTable = pgTable(
  'user_preferences',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    userId: uuid('user_id').notNull(), // Links to the user
    preferences: jsonb('preferences').default({}).notNull(),
    createdAt: timestamp('created_at').defaultNow().notNull(),
    updatedAt: timestamp('updated_at').defaultNow().notNull(),
  },
  (table) => [
    index('idx_user_preferences_user_id').on(table.userId),
  ]
);
```

**Rules:**
- ✅ **ALWAYS** omit `agentId` for shared tables
- ✅ **ALWAYS** use `userId` or other identifiers to scope data
- ✅ **ALWAYS** add appropriate indexes for query performance
- ✅ **ALWAYS** use Drizzle ORM schema definitions
- ✅ **NEVER** include `agentId` in shared tables

### Agent-Specific Tables (With agentId)

**Pattern:** Tables scoped to individual agents

```typescript
export const agentDataTable = pgTable(
  'agent_data',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    agentId: uuid('agent_id').notNull(), // Scopes to specific agent
    key: varchar('key', { length: 255 }).notNull(),
    value: jsonb('value').notNull(),
    createdAt: timestamp('created_at').defaultNow().notNull(),
  },
  (table) => [
    index('idx_agent_data_agent_key').on(table.agentId, table.key),
  ]
);
```

**Rules:**
- ✅ **ALWAYS** include `agentId` for agent-scoped data
- ✅ **ALWAYS** use composite indexes for common queries
- ✅ **ALWAYS** consider data isolation requirements

## Repository Pattern

**MANDATORY**: Encapsulate all database operations in repository classes

```typescript
export class UserPreferencesRepository {
  constructor(private readonly db: ReturnType<typeof drizzle>) {}

  async upsert(userId: UUID, preferences: Record<string, any>): Promise<UserPreferences> {
    const existing = await this.findByUserId(userId);
    
    if (existing) {
      const [updated] = await this.db
        .update(userPreferencesTable)
        .set({ preferences, updatedAt: new Date() })
        .where(eq(userPreferencesTable.userId, userId))
        .returning();
      return this.mapToUserPreferences(updated);
    } else {
      const [created] = await this.db
        .insert(userPreferencesTable)
        .values({ userId, preferences, createdAt: new Date(), updatedAt: new Date() })
        .returning();
      return this.mapToUserPreferences(created);
    }
  }

  private mapToUserPreferences(row: any): UserPreferences {
    return {
      id: row.id as UUID,
      userId: row.userId || row.user_id,
      preferences: row.preferences || {},
      createdAt: row.createdAt || row.created_at,
      updatedAt: row.updatedAt || row.updated_at,
    };
  }
}
```

**Rules:**
- ✅ **ALWAYS** create repository classes for database operations
- ✅ **ALWAYS** map database rows to domain types
- ✅ **ALWAYS** handle both camelCase and snake_case field names
- ✅ **ALWAYS** provide CRUD operations
- ✅ **ALWAYS** use Drizzle ORM query builder
- ✅ **NEVER** access database directly from actions/providers

### Transactions

**Pattern:** Use transactions for multi-step operations

```typescript
async transferPoints(fromUserId: UUID, toUserId: UUID, points: number): Promise<void> {
  await this.db.transaction(async (tx) => {
    await tx.update(userPointsTable).set({ points: sql`${userPointsTable.points} - ${points}` })
      .where(eq(userPointsTable.userId, fromUserId));
    await tx.update(userPointsTable).set({ points: sql`${userPointsTable.points} + ${points}` })
      .where(eq(userPointsTable.userId, toUserId));
    await tx.insert(transactionLogTable).values({ fromUserId, toUserId, amount: points });
  });
}
```

**Rules:**
- ✅ **ALWAYS** use transactions for multi-step operations
- ✅ **ALWAYS** handle transaction errors
- ✅ **ALWAYS** log transactions

## Actions for Writing Data

**Pattern:** Extract structured data and store using repository

```typescript
export const storeUserPreferencesAction: Action = {
  name: 'STORE_USER_PREFERENCES',
  description: 'Extract and store user preferences from messages',
  
  validate: async (runtime, message) => {
    const text = message.content.text?.toLowerCase() || '';
    return text.includes('preference') || text.includes('prefer');
  },
  
  handler: async (runtime, message) => {
    // 1. Create prompt for LLM to extract structured data
    const extractionPrompt = `Extract user preferences from: "${message.content.text}"`;
    
    // 2. Use runtime's LLM
    const llmResponse = await runtime.completion({
      messages: [{ role: 'system', content: extractionPrompt }]
    });
    
    // 3. Parse the response
    const extractedPreferences = parseKeyValueXml(llmResponse.content);
    
    // 4. Get database and repository
    const db = runtime.databaseAdapter.db;
    const repository = new UserPreferencesRepository(db);
    
    // 5. Store preferences
    const userId = message.userId || message.entityId;
    const stored = await repository.upsert(userId, extractedPreferences);
    
    return {
      success: true,
      data: stored,
      text: 'Your preferences have been saved successfully.'
    };
  }
};
```

**Rules:**
- ✅ **ALWAYS** use `parseKeyValueXml` for structured extraction
- ✅ **ALWAYS** access database via `runtime.databaseAdapter.db`
- ✅ **ALWAYS** use repository pattern for database operations
- ✅ **ALWAYS** return ActionResult with success and data
- ✅ **ALWAYS** handle errors gracefully

## Providers for Reading Data

**Pattern:** Fetch data and format for agent context

```typescript
export const userPreferencesProvider: Provider = {
  name: 'USER_PREFERENCES',
  description: 'Provides user preferences to customize agent behavior',
  dynamic: true, // Fetches fresh data on each request
  
  get: async (runtime, message) => {
    const userId = message.userId || message.entityId;
    const db = runtime.databaseAdapter.db;
    const repository = new UserPreferencesRepository(db);
    const userPrefs = await repository.findByUserId(userId);
    
    if (!userPrefs) {
      return {
        data: { preferences: {} },
        values: { preferences: 'No preferences found' },
        text: ''
      };
    }
    
    const preferencesText = `# User Preferences
${Object.entries(userPrefs.preferences).map(([key, value]) => 
  `- ${key}: ${value}`
).join('\n')}`;
    
    return {
      data: { preferences: userPrefs.preferences },
      values: userPrefs.preferences,
      text: preferencesText // This text is added to agent context
    };
  }
};
```

**Rules:**
- ✅ **ALWAYS** set `dynamic: true` for fresh data
- ✅ **ALWAYS** access database via `runtime.databaseAdapter.db`
- ✅ **ALWAYS** format text for LLM consumption
- ✅ **ALWAYS** return ProviderResult with text, values, data
- ✅ **ALWAYS** handle missing data gracefully

## Plugin Registration

**Pattern:** Register schema, actions, and providers

```typescript
export const myPlugin: Plugin = {
  name: 'my-plugin',
  description: 'My custom plugin',
  actions: [storeUserPreferencesAction],
  providers: [userPreferencesProvider],
  schema: customSchema, // Your schema export
};
```

**Rules:**
- ✅ **ALWAYS** export schema from schema file
- ✅ **ALWAYS** register schema in plugin configuration
- ✅ **ALWAYS** register actions and providers that use schema

## Type Safety

**Pattern:** Define interfaces for domain types

```typescript
export interface UserPreferences {
  id: UUID;
  userId: UUID;
  preferences: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}
```

**Rules:**
- ✅ **ALWAYS** define interfaces for domain types
- ✅ **ALWAYS** map database rows to domain types in repository
- ✅ **ALWAYS** handle both camelCase and snake_case field names
- ✅ **ALWAYS** use UUID type from `@elizaos/core`

## Error Handling

**Pattern:** Handle database errors gracefully

```typescript
try {
  const result = await repository.upsert(userId, preferences);
  return { success: true, data: result };
} catch (error) {
  console.error('Failed to store preferences:', error);
  return { 
    success: false, 
    error: error instanceof Error ? error.message : 'Unknown error' 
  };
}
```

**Rules:**
- ✅ **ALWAYS** wrap database operations in try-catch
- ✅ **ALWAYS** log errors with context
- ✅ **ALWAYS** return proper error in ActionResult
- ✅ **NEVER** throw unhandled errors

## Advanced Patterns

### Embeddings and Vector Search

```typescript
export const documentTable = pgTable('documents', {
  id: uuid('id').primaryKey().defaultRandom(),
  content: text('content').notNull(),
  embedding: vector('embedding', { dimensions: 1536 }),
  metadata: jsonb('metadata').default({})
});

export class DocumentRepository {
  async searchSimilar(embedding: number[], limit = 10): Promise<Document[]> {
    return await this.db
      .select()
      .from(documentTable)
      .orderBy(sql`${documentTable.embedding} <-> ${embedding}`)
      .limit(limit);
  }
}
```

### Time-Series Data

```typescript
export const metricsTable = pgTable('metrics', {
  id: uuid('id').primaryKey().defaultRandom(),
  metric: varchar('metric', { length: 255 }).notNull(),
  value: real('value').notNull(),
  timestamp: timestamp('timestamp').defaultNow().notNull(),
  tags: jsonb('tags').default({})
});
```

## Best Practices Checklist

Before implementing database schema, verify:

- [ ] Schema defined with Drizzle ORM
- [ ] Shared tables omit `agentId`
- [ ] Agent-specific tables include `agentId`
- [ ] Repository class created for database operations
- [ ] Actions use repository for writing data
- [ ] Providers use repository for reading data
- [ ] Domain types defined with interfaces
- [ ] Error handling implemented
- [ ] Indexes added for query performance
- [ ] Schema registered in plugin configuration

## Forbidden Patterns

❌ **NEVER**:
- Access database directly without repository
- Include `agentId` in shared tables
- Skip error handling in database operations
- Skip type mapping in repository
- Skip indexes for common queries
- Throw unhandled errors from actions/providers

## Required Patterns

✅ **ALWAYS**:
- Use repository pattern for database access
- Access database via `runtime.databaseAdapter.db`
- Map database rows to domain types
- Handle errors gracefully
- Use Drizzle ORM query builder
- Add indexes for query performance
- Register schema in plugin configuration

## Examples

See `.cursor/memory/elizaos-database-schema.md` for complete examples of:
- Shared table definitions
- Agent-specific table definitions
- Repository patterns
- Transaction patterns
- Actions for writing data
- Providers for reading data
- Advanced patterns (embeddings, time-series)
