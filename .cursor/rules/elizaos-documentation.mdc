---
alwaysApply: true
description: Comprehensive ElizaOS documentation enforcement for plugin-eliza development
---

# ElizaOS Documentation Enforcement Rules for Hyperscape Plugin

## Core Principle

**ALWAYS reference official ElizaOS documentation before implementing any ElizaOS-related functionality in the plugin-eliza package.** The Hyperscape plugin integrates ElizaOS agents into the game world, and must follow current ElizaOS patterns exactly.

## Required Documentation Sources

### Primary Documentation Hub
- **Main Documentation**: https://docs.elizaos.ai/
  - Use for: General framework overview, understanding agent runtime, memory systems, navigation
  - Reference when: Extending plugin functionality, understanding agent lifecycle, troubleshooting

### Plugin Development
- **Create a Plugin Guide**: https://docs.elizaos.ai/guides/create-a-plugin
  - Use for: Building plugin actions, providers, services for Hyperscape integration
  - Reference when: Adding new agent capabilities, creating game-world actions, implementing providers
  - Key workflow:
    1. Create plugin structure following documented patterns
    2. Implement actions for game interactions (move, attack, interact, build)
    3. Create providers for world state context
    4. Build services for WebSocket connections to Hyperscape worlds
    5. Test with component and E2E tests

### Project Configuration
- **Projects Overview**: https://docs.elizaos.ai/projects/overview
  - Use for: Understanding how agents are configured, character setup, runtime initialization
  - Reference when: Configuring agents to join Hyperscape worlds, setting up character personalities
  - Key concepts:
    - Projects contain one or more agents
    - Character files define agent personalities
    - Plugins loaded via character.plugins array
    - Runtime manages agent lifecycle

- **Environment Variables**: https://docs.elizaos.ai/projects/environment-variables
  - Use for: Required API keys for model providers, plugin configuration
  - Reference when: Setting up agent environment, configuring model providers for game agents
  - Required for Hyperscape agents:
    - Model provider keys: `OPENAI_API_KEY`, `ANTHROPIC_API_KEY`, etc.
    - Database config: `DATABASE_URL` (if using SQL plugin)
    - Server config: `ELIZA_SERVER_AUTH_TOKEN`, `ELIZA_UI_ENABLE`, `NODE_ENV`

### Plugin Architecture
- **Plugin Architecture**: https://docs.elizaos.ai/plugins/architecture
  - Use for: Understanding plugin components, action/provider/service patterns, plugin lifecycle
  - Reference when: Designing Hyperscape-specific actions (move, attack, interact), creating world state providers
  - Critical for plugin-eliza:
    - **Actions**: Game world interactions (GOTO, USE_ITEM, REPLY, BUILD, etc.)
    - **Providers**: World state context (HYPERSCAPE_WORLD_STATE, HYPERSCAPE_EMOTE_LIST)
    - **Services**: HyperscapeService for WebSocket connections and world management
    - **Component Registration Order**: Database → Actions → Evaluators → Providers → Models → Routes → Events

### REST API Reference
- **Create Agent API**: https://docs.elizaos.ai/rest-reference/agents/create-a-new-agent
  - Use for: Programmatic agent creation, API-based agent management
  - Reference when: Creating agents dynamically, managing agent lifecycle via API
  - Endpoint: `POST /api/agents`
  - Request requires `characterPath` and `characterJson` with plugins array including `@hyperscape/plugin-eliza`

## Hyperscape-Specific Integration Points

### When Creating Actions

Actions allow agents to interact with the Hyperscape game world. Reference:
- https://docs.elizaos.ai/guides/create-a-plugin (Action patterns)
- https://docs.elizaos.ai/plugins/architecture (Action structure)

**Action Interface**:
```typescript
interface Action {
  name: string;                    // e.g., 'GOTO', 'USE_ITEM', 'REPLY'
  similes: string[];               // Alternative names for LLM matching
  description: string;            // What the action does in game context
  validate: (runtime, message, state) => Promise<boolean>;
  handler: (runtime, message, state, options, callback) => Promise<ActionResult>;
  examples: ActionExample[][];     // Training examples for LLM
}
```

**Hyperscape Action Examples**:
- `GOTO`: Navigate to coordinates or entities
- `USE_ITEM`: Interact with game objects
- `REPLY`: Send chat messages
- `HYPERSCAPE_EDIT_ENTITY`: Build/edit world entities
- `WALK_RANDOMLY`: Autonomous movement
- `PERCEPTION`: Observe world state

Required checks:
- [ ] Action follows documented Action interface exactly
- [ ] Validation logic checks HyperscapeService availability
- [ ] Handler uses HyperscapeService methods properly
- [ ] Returns proper ActionResult structure
- [ ] Examples array includes game-world scenarios
- [ ] Similes array includes relevant game action keywords
- [ ] Error handling for world connection failures

### When Creating Providers

Providers give agents context about the game world state. Reference:
- https://docs.elizaos.ai/plugins/architecture (Provider patterns)
- https://docs.elizaos.ai/guides/create-a-plugin (Provider examples)

**Provider Interface**:
```typescript
interface Provider {
  name: string;                    // e.g., 'HYPERSCAPE_WORLD_STATE'
  description: string;             // What context it provides
  dynamic?: boolean;               // true for real-time world state
  get: (runtime, message, state?) => Promise<ProviderResult>;
}

interface ProviderResult {
  text: string;      // Formatted for LLM context
  values: object;   // Structured data for templates
  data: object;      // Raw data for processing
}
```

**Hyperscape Provider Examples**:
- `HYPERSCAPE_WORLD_STATE`: Entity positions, nearby objects, chat history, agent position
- `HYPERSCAPE_EMOTE_LIST`: Available animations/emotes
- `CHARACTER`: Agent personality and behavior
- `ACTIONS`: Available actions based on current state

Required checks:
- [ ] Provider follows documented Provider interface
- [ ] Get method returns proper ProviderResult format
- [ ] Provider is registered correctly in plugin (4th in order)
- [ ] Context includes relevant game state information
- [ ] Text formatted clearly for LLM comprehension
- [ ] Dynamic providers update in real-time
- [ ] Efficient data gathering (cache when appropriate)

### When Creating Services

Services manage connections and state between ElizaOS and Hyperscape. Reference:
- https://docs.elizaos.ai/plugins/architecture (Service patterns)
- https://docs.elizaos.ai/projects/overview (Service lifecycle)

**Service Structure**:
```typescript
class HyperscapeService extends Service {
  static serviceType = 'hyperscape';
  
  async initialize(runtime: IAgentRuntime): Promise<void> {
    // WebSocket connection setup
    // World state initialization
    // Event listener registration
  }
  
  async isConnected(): boolean {
    // Check WebSocket connection status
  }
  
  async cleanup(): Promise<void> {
    // Close connections
    // Remove event listeners
    // Clean up resources
  }
}
```

**HyperscapeService Responsibilities**:
1. **Connection Management**:
   - WebSocket connection to Hyperscape world server
   - Authentication and session handling
   - Reconnection logic with exponential backoff
   - Connection state tracking

2. **World Interface**:
   - Access to world entities (players, objects, NPCs)
   - Player/agent controls (movement, interaction)
   - Chat system interface
   - Build/edit capabilities

3. **Sub-Managers**:
   - MessageManager: Chat history and message sending
   - BuildManager: World editing capabilities
   - Controls: Agent movement and interaction

Required checks:
- [ ] Service extends documented Service base class
- [ ] Initialize method follows documented pattern
- [ ] Service manages WebSocket connections properly
- [ ] Service integrates with Hyperscape world systems
- [ ] Connection resilience (reconnection logic)
- [ ] Resource management (cleanup on shutdown)
- [ ] Error handling for network failures

## Mandatory Workflow for Plugin Development

### Before Implementing Any Feature

1. **Check Documentation**
   ```bash
   # Use web search with site:docs.elizaos.ai
   # Query: "plugin actions" OR "plugin providers" OR "plugin services"
   # Use Context7 MCP to query ElizaOS documentation
   ```

2. **Verify Integration Points**
   - Check how actions connect to Hyperscape systems
   - Verify provider context format matches agent expectations
   - Ensure service lifecycle aligns with game world lifecycle
   - Review existing plugin-eliza code for patterns

3. **Follow Official Patterns**
   - Use documented plugin structure exactly
   - Follow action validation patterns from docs
   - Implement providers as documented
   - Manage services according to lifecycle docs

### When Adding New Actions

**MANDATORY**: Reference https://docs.elizaos.ai/guides/create-a-plugin

Example workflow for Hyperscape action:
1. **Review Action Creation Guide**
   - Understand Action interface requirements
   - Study example actions from documentation
   - Review action validation patterns

2. **Implement Validation**
   ```typescript
   validate: async (runtime, message, state) => {
     const service = runtime.getService<HyperscapeService>('hyperscape');
     if (!service || !service.isConnected()) {
       return false; // Cannot execute without world connection
     }
     // Additional validation logic
     return true;
   }
   ```

3. **Implement Handler**
   ```typescript
   handler: async (runtime, message, state, options, callback) => {
     try {
       const service = runtime.getService<HyperscapeService>('hyperscape');
       // Use service methods to affect world
       await service.movePlayer(playerId, position);
       
       await callback({
         text: 'Action completed',
         action: 'GOTO',
         source: 'hyperscape'
       });
       
       return {
         success: true,
         text: 'Moved to position',
         values: { position },
         data: { action: 'GOTO' }
       };
     } catch (error) {
       // Error handling
     }
   }
   ```

4. **Add Examples and Similes**
   - Include game-world conversation examples
   - Add similes for natural language matching
   - Cover success and failure scenarios

5. **Test Using Documented Patterns**
   - Component tests for validation logic
   - E2E tests for complete integration
   - Manual testing in Hyperscape world

### When Configuring Agent Environment

**MANDATORY**: Reference https://docs.elizaos.ai/projects/environment-variables

Required environment variables for Hyperscape agents:
```env
# Model Provider (choose one or more)
OPENAI_API_KEY=sk-your-key-here
ANTHROPIC_API_KEY=your-anthropic-key-here

# Database (if using SQL plugin)
DATABASE_URL=sqlite://./data/agent.db

# Server Configuration
ELIZA_SERVER_AUTH_TOKEN=secure-token-for-production
ELIZA_UI_ENABLE=true  # or false for headless
NODE_ENV=development   # or production

# Hyperscape-specific (if needed)
HYPERSCAPE_WORLD_URL=ws://localhost:8080
```

### When Managing Agent Lifecycle

**MANDATORY**: Reference https://docs.elizaos.ai/projects/overview

Understand:
- **Agent Initialization**: How agents start up and load plugins
- **Plugin Loading**: Order matters - dependencies load first
- **Runtime Management**: How runtime manages agent state
- **Service Lifecycle**: Initialize → Connect → Operate → Cleanup
- **World Connection**: How agents connect to Hyperscape worlds

## Version Compatibility

- **Check ElizaOS version in package.json**
- Current in plugin-eliza: `@elizaos/core": "^1.2.9"`
- Verify plugin patterns match this version
- Check for breaking changes when upgrading
- Reference migration guides if version changes
- Test thoroughly after version updates

## Plugin Component Registration Order

**CRITICAL**: Components must register in this exact order:

1. **Database Adapter** (if provided)
2. **Actions** ← Hyperscape actions register here
3. **Evaluators**
4. **Providers** ← Hyperscape providers register here
5. **Models**
6. **Routes**
7. **Events**

**Why Order Matters**:
- Actions may depend on database adapter
- Providers may use actions for context
- Services initialize before components use them
- Breaking order causes initialization failures

## Testing Requirements

Reference plugin testing patterns from:
- https://docs.elizaos.ai/guides/create-a-plugin (Testing section)

Required test types for plugin-eliza:

1. **Component Tests**:
   ```typescript
   // Test actions/providers/services in isolation
   describe('HyperscapeAction', () => {
     it('validates when service connected', async () => {
       const mockRuntime = {
         getService: () => ({ isConnected: () => true })
       };
       const isValid = await action.validate(mockRuntime, message);
       expect(isValid).toBe(true);
     });
   });
   ```

2. **E2E Tests**:
   ```typescript
   // Test agent integration with Hyperscape world
   export const HyperscapeTestSuite = {
     name: 'hyperscape-integration',
     tests: [{
       name: 'agent connects to world',
       fn: async (runtime) => {
         const service = runtime.getService('hyperscape');
         expect(service.isConnected()).toBe(true);
       }
     }]
   };
   ```

3. **Integration Tests**:
   - Test plugin loading and initialization
   - Verify WebSocket connection
   - Test action execution in real world
   - Validate provider context accuracy

## Hyperscape-Specific Patterns

### Action Pattern
```typescript
export const hyperscapeAction: Action = {
  name: 'ACTION_NAME',
  similes: ['ALTERNATIVE_NAME', 'SIMILAR_ACTION'],
  description: 'What this action does in Hyperscape',
  
  validate: async (runtime, message, state) => {
    const service = runtime.getService<HyperscapeService>('hyperscape');
    return service?.isConnected() ?? false;
  },
  
  handler: async (runtime, message, state, options, callback) => {
    const service = runtime.getService<HyperscapeService>('hyperscape');
    // Use service methods
    await callback({ text: 'Action result', action: 'ACTION_NAME' });
    return { success: true, text: 'Success', values: {}, data: {} };
  },
  
  examples: [
    [
      { name: 'user', content: { text: 'Example user message' } },
      { name: 'agent', content: { text: 'Example agent response' } }
    ]
  ]
};
```

### Provider Pattern
```typescript
export const hyperscapeProvider: Provider = {
  name: 'HYPERSCAPE_WORLD_STATE',
  description: 'Provides current Hyperscape world state',
  dynamic: true,
  
  get: async (runtime, message, state) => {
    const service = runtime.getService<HyperscapeService>('hyperscape');
    const worldState = service.getWorldState();
    
    return {
      text: formatWorldStateForLLM(worldState),
      values: { entities: worldState.entities },
      data: worldState
    };
  }
};
```

### Service Pattern
```typescript
export class HyperscapeService extends Service {
  static serviceType = 'hyperscape';
  
  private ws: WebSocket | null = null;
  private world: World | null = null;
  
  async initialize(runtime: IAgentRuntime): Promise<void> {
    // Connect to Hyperscape world
    this.ws = new WebSocket(this.config.worldUrl);
    // Setup event handlers
    // Initialize world state
  }
  
  isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }
  
  async cleanup(): Promise<void> {
    this.ws?.close();
    this.ws = null;
    this.world = null;
  }
}
```

## Forbidden Patterns

❌ **NEVER** implement actions without checking Action interface documentation
❌ **NEVER** assume provider context format without verifying docs
❌ **NEVER** skip environment variable validation
❌ **NEVER** use deprecated plugin patterns
❌ **NEVER** hardcode configuration that should be in environment variables
❌ **NEVER** bypass documented plugin lifecycle hooks
❌ **NEVER** ignore component registration order
❌ **NEVER** skip service initialization/cleanup
❌ **NEVER** assume WebSocket connection state

## Required Patterns

✅ **ALWAYS** check documentation before implementing plugin features
✅ **ALWAYS** verify Action/Provider/Service interfaces match current docs
✅ **ALWAYS** follow documented plugin structure
✅ **ALWAYS** respect component registration order
✅ **ALWAYS** validate environment variables per documentation
✅ **ALWAYS** use documented testing patterns
✅ **ALWAYS** check version compatibility before upgrading
✅ **ALWAYS** handle WebSocket connection failures gracefully
✅ **ALWAYS** implement proper service lifecycle (init → connect → cleanup)
✅ **ALWAYS** validate service availability in action handlers

## Quick Reference Checklist

Before implementing any plugin-eliza feature:
- [ ] Action/Provider/Service pattern verified in documentation
- [ ] Environment variables match documented requirements
- [ ] Plugin structure follows official architecture
- [ ] Component registration order is correct
- [ ] Integration points verified with Hyperscape systems
- [ ] Version compatibility confirmed (`@elizaos/core": "^1.2.9"`)
- [ ] Testing patterns follow documentation
- [ ] Service lifecycle properly implemented
- [ ] Error handling for connection failures
- [ ] Examples and similes included for actions

## Integration with Hyperscape Rules

This rule works alongside:
- **Hyperscape Development Rules**: Plugin must integrate properly with game systems
- **Testing Standards**: Use real Hyperscape worlds, not mocks
- **TypeScript Strong Typing**: Follow ElizaOS type patterns from documentation
- **Real Code Only**: No examples or shortcuts, production-ready code

---

**Remember**: The plugin-eliza package bridges ElizaOS and Hyperscape. Following official ElizaOS documentation ensures proper agent behavior and compatibility with the framework. The framework evolves rapidly - always verify current patterns before implementing.
